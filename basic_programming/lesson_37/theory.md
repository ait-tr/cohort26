# Полиморфизм

Полиморфизм – это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта.

Поскольку Java относится к строго типизированным языкам, в программном коде всегда нужно указать тип объекта при объявлении переменных. Cтрогая типизация повышает безопасность кода, и надежность программы и позволяет еще на стадии компиляции предотвратить ошибки несовместимости типов (например, попытку разделить строку на число). Естественно, компилятор должен «знать» объявляемый тип – это может быть класс из JDK или созданный нами собственноручно.

При работе с программным кодом мы можем использовать не только объекты типа, который мы назначили при объявлении, но и его наследников. Это важный момент: мы можем работать со многими типами, как с одним (при условии, что эти типы являются производными от базового типа). Также это значит, что, объявив переменную типа суперкласса, мы можем присвоить ей значение одного из наследников.

Вкратце полиморфизм можно описать так: ***"Один интерфейс — много реализаций"***.

# Переопределение методов

Мы уже знакомы с полиморфизмом на примере разновидностей списков - и ArrayList, и LinkedList имеют одинаковый интерфейс.

Давайте покажем, как создать класс `Animal` с универсальным методом `voice()` так, чтобы его потомки могли **переопределить** этот метод.

```java
public class Animal {

  public void voice() {
   System.out.println("Голос!");
  }
}

public class Bear extends Animal {

  @Override
  public void voice() {
    System.out.println("Р-р-р!");
  }
}

public class Cat extends Animal {

  @Override
  public void voice() {
    System.out.println("Мяу!");
  }
}

public class Dog extends Animal {

  @Override
  public void voice() {
    System.out.println("Гав!");
  }
}
```

Для переопределения метода (method overriding) в дочернем классе мы должны указать **аннотацию** (annotation) `@Override`.

При вызове метода Java будет искать его по иерархии "снизу вверх", начиная с класса и переходя к его предкам.

Найдёт метод в "самом дочернем" классе - вызовет его и на этом остановится.

Не найдёт здесь - пойдёт в класс-предок и будет искать там.

Эта цепочка продолжится до "самого базового" класса `Object`. Если метода нет даже там, то Java не даст даже запустить программу, сказав, что не может найти указанный метод.

# Правила переопределения

## Модификатор доступа

Потомок может оставить доступ таким же или **расширить** доступ, но не может его **сузить** - не выполнится обещание суперкласса, метод перестанет быть доступным.

Приватные методы изначально недоступны потомку и не могут быть перезаписаны.

```java
class Parent {

  // приватный метод, нельзя перезаписать, существует только в классе Parent
  private void m1() {
    System.out.println("From parent m1()");
  }

  protected void m2() {
    System.out.println("From parent m2()");
  }
}

class Child extends Parent {

  // новый метод m1(), существует только в классе Child
  private void m1()
  {
      System.out.println("From child m1()");
  }

  // перезаписанный метод с расширенным доступом.
  @Override
  public void m2() {
    System.out.println("From child m2()");
  }
}
```

## Final нельзя перезаписать

Правило достаточно простое. Ключевое слово `final` означает, что метод нельзя перезаписать, а переменную - изменить.

## Static нельзя перезаписать, но можно скрыть

При вызове статического метода мы указываем класс, метод которого вызываем.

При описании и вызове статического метода внутри класса с такой же сигнатурой, как и в суперклассе, метод суперкласса будет "спрятан". Вызовется метод дочернего класса.

При перезаписи нельзя превратить не-статический метод в статический и наоборот.

## Сигнатура

Метод в дочернем классе должен иметь:
- такой же тип возвращаемого значения (или его тип-потомок),
   если базовый метод возвращает `List<Integer>`, то дочерний метод может вернуть:
   - `List<Integer>`,
   - `ArrayList<Integer>`,
   - любой другой наследник класса `List<Integer>`.
- такое же название,
- такие же типы и порядок аргументов.

## Проверяемые исключения

Если базовый метод выбрасывает проверяемые исключения, то дочерний метод может выбрасывать такие же проверяемые исключения или их подклассы.

У дочернего метода не может появиться "новых" проверяемых исключений.

# Метод `toString()`

У всех классов Java существует "базовый" метод `public String toString()`. Именно его результат используется при любом преобразовании в строку, в том числе при выводе на печать.

Для красивого вывода можно перезаписать этот метод:

```java
public class Cat {

  private String name;

  public Cat(String name) {
    this.name = name;
  }

  @Override
  public String toString() {
    return String.format("Кошка по имени %s", name);
  }
}

public class Main {

  public static void main(String[] args) {
    Cat murka = new Cat("Мурка");
    System.out.println(murka); // выведет "Кошка по имени Мурка"
  }
}
```
