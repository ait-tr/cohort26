# Юнит-тестирование

**Модульное тестирование**, или **юнит-тестирование** (*англ.* **unit testing**) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.

Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

## Не нужно писать тесты, если

- Вы делаете простой сайт-визитку из 5 статических html-страниц и с одной формой отправки письма. На этом заказчик, скорее всего, успокоится, ничего большего ему не нужно. Здесь нет никакой особенной логики, быстрее просто все проверить «руками»
- Вы занимаетесь рекламным сайтом/простыми флеш-играми или баннерами – сложная верстка/анимация или большой объем статики. Никакой логики нет, только представление
- Вы делаете проект для выставки. Срок – от двух недель до месяца, ваша система – комбинация железа и софта, в начале проекта не до конца известно, что именно должно получиться в конце. Софт будет работать 1-2 дня на выставке
- Вы всегда пишете код без ошибок, обладаете идеальной памятью и даром предвидения. Ваш код настолько крут, что изменяет себя сам, вслед за требованиями клиента. Иногда код объясняет клиенту, что его требования не нужно реализовывать

**Тесты очень нужно писать в тестовых заданиях.**

В первых трех случаях по объективным причинам (сжатые сроки, бюджеты, размытые цели или очень простые требования) вы не получите выигрыша от написания тестов.

Последний случай рассмотрим отдельно. Я знаю только одного такого человека, и если вы не узнали себя на фото ниже, то у меня для вас плохие новости.
![](https://github.com/ait-tr/cohort24/raw/8aeebe8206e129e6e4c2db178ca265283bbec1ed/basic_programming/lesson_47/img/63568c35676c4d929422ec8e42dd3563.jpg)

**Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно быть переписанным с нуля.**

Ваши тесты должны:
- Быть достоверными
- Не зависеть от окружения, на котором они выполняются
- Легко поддерживаться
- Легко читаться и быть простыми для понимания (даже новый разработчик должен понять, **что именно** тестируется)
- Соблюдать единую конвенцию именования
- Запускаться регулярно в автоматическом режиме

## Выберите логическое расположение тестов в вашей VCS
Только так. Ваши тесты должны быть частью контроля версий. В зависимости от типа вашего решения, они могут быть организованы по-разному.

Общая рекомендация:
- если приложение монолитное, положите все тесты в папку `Tests`;
- если у вас много разных компонентов, храните тесты в папке каждого компонента.

## Выберите способ именования проектов с тестами
Одна из лучших практик: добавьте к каждому проекту его собственный тестовый проект.

У вас есть части системы `<PROJECT_NAME>.Core`, `<PROJECT_NAME>.Bl` и `<PROJECT_NAME>.Web`? Добавьте еще `<PROJECT_NAME>.Core.Tests`, `<PROJECT_NAME>.Bl.Tests` и `<PROJECT_NAME>.Web.Tests`.

## Используйте такой же способ именования для тестовых классов
У вас есть класс `ProblemResolver`? Добавьте в тестовый проект `ProblemResolverTests`. Каждый тестирующий класс должен тестировать только одну сущность.

## Выберите «говорящий» способ именования методов тестирующих классов
`TestLogin` – не самое лучшее название метода. Что именно тестируется? Каковы входные параметры? Могут ли возникать ошибки и исключительные ситуации?

Один из возможных способов именования методов такой: `[Тестируемый метод]_[Сценарий]_[Ожидаемое поведение]`.

Предположим, что у нас есть класс `Calculator`, а у него есть метод `sum`, который должен складывать два числа.
В этом случае наш тестирующий класс будет выглядеть так:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public сlass CalculatorTests {

	@Test
  public void sum_2Plus5_7Returned() {
    // …
  }
}
```
Такая запись понятна без объяснений. Это спецификация к вашему коду.

## Придерживайтесь единого стиля написания тела теста
Отлично зарекомендовал себя подход **AAA** (arrange, act, assert - упорядочить, выполнить действие, сравнить результат).

Вернемся к примеру с калькулятором:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		// arrange
		Calculator calc = new Calculator();
	
		// act
		int res = calc.sum(2, 5);

		// assert
		assertEquals(7, res);
	}
}
```
Такая форма записи гораздо легче читается, чем
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

  @Test
	public void sum_2Plus5_7Returned() {
		assertEquals(7, new Calculator().sum(2, 5));
	}
}
```

## Тестируйте одну вещь за один раз
Каждый тест должен проверять только одну вещь. Если процесс слишком сложен (например, покупка в интернет магазине), разделите его на несколько частей и протестируйте их отдельно.

Если вы не будете придерживаться этого правила, ваши тесты станут нечитаемыми, и вскоре вам окажется очень сложно их поддерживать.

# Фреймворк JUnit

**JUnit** - один из самых популярных фреймворков, используемых для тестирования кода в **Java**.

[Официальный сайт](https://junit.org/junit5/)

[Руководство пользователя](https://junit.org/junit5/docs/current/user-guide/)

[Репозиторий](https://github.com/junit-team/junit5/) на **GitHub**

[Текстовая инструкция по настройке IntelliJ Idea (на английском)](https://www.jetbrains.com/help/idea/junit.html)

[Видеоинструкция по настройке IntelliJ Idea (на английском)](https://www.youtube.com/watch?v=we3zJE3hlWE)

## Волшебные импорты

Эти два импорта заставят IntelliJ Idea предложить вам установить JUnit:
```java
import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
```
