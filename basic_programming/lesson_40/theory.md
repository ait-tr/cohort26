# Интерфейсы

Сегодня поговорим о важном понятии в **Java** — интерфейсы.

Слово вам наверняка знакомо. Например, интерфейсы есть у большинства компьютерных программ и игр.

В широком смысле интерфейс — некий «пульт», который связывает две взаимодействующие друг с другом стороны.

Простой пример интерфейса из повседневной жизни — пульт от телевизора.

Он связывает два объекта, человека и телевизор, и выполняет разные задачи: прибавить или убавить звук, переключить каналы, включить или выключить телевизор.

Одной стороне (человеку) нужно обратиться к интерфейсу (нажать на кнопку пульта), чтобы вторая сторона выполнила действие. Например, чтобы телевизор переключил канал на следующий. При этом пользователю не обязательно знать устройство телевизора и то, как внутри него реализован процесс смены канала.

Всё, к чему пользователь имеет доступ — это интерфейс. Главная задача — получить нужный результат.

В Java тоже можно создавать интерфейс - набор абстрактных методов (кнопок пульта), который должен быть у класса, реализующего (*implement*) этот интерфейс.

Создание интерфейса очень похоже на создание обычного класса, только вместо слова `class` мы указываем слово `interface`.

Давай посмотрим на простейший Java-интерфейс, и разберемся, как он работает и для чего нужен:

```java
public interface Swimmable  {

  public void swim();
}
```

Мы создали интерфейс `Swimmable` — «умеющий плавать». Это что-то вроде нашего пульта, у которого есть одна «кнопка»: метод `swim()`  — «плыть».

Как же нам этот «пульт» использовать?

Для этого метод, т.е. кнопку нашего пульта, нужно **имплементировать** (реализовать). Чтобы использовать интерфейс, его методы должны реализовать какие-то классы нашей программы.

Давай придумаем класс, объекты которого подойдут под описание «умеющий плавать». Например, подойдет класс утки — `Duck`:
```java
public class Duck implements Swimmable {

  public void swim() {
    System.out.println("Уточка, плыви!");
  }
}
```
Что же мы здесь видим?

Класс `Duck` «связывается» с интерфейсом `Swimmable` при помощи ключевого слова `implements` (реализовывает). Мы использовали похожий механизм для связи двух классов в наследовании, только там было слово «`extends`».

«`public class Duck implements Swimmable`» можно для понятности перевести дословно: «публичный класс `Duck` реализует интерфейс `Swimmable`».

Это значит, что класс, связанный с каким-то интерфейсом, должен реализовать **все** его методы. Обратите внимание: в нашем классе `Duck`, прямо как в интерфейсе `Swimmable`, есть перезаписанный метод `swim()`, и внутри него содержится какая-то логика.

Это обязательное требование. Если бы мы просто написали «`public class Duck implements Swimmable`» и не создали бы метод `swim()` в классе `Duck`, компилятор выдал бы нам ошибку:
```
Duck is not abstract and does not override abstract method swim() in Swimmable
```

Подобную ошибку мы уже видели при наследовании от абстрактного класса, если забывали переопределить абстрактный метод. Механизм здесь точно такой же.

# `default` методы интерфейса

Методы в интерфейсах обычно «пустые», то есть они не имеют реализации.

Причина этого проста: интерфейс **описывает** поведение, а не **реализует** его.

«Все объекты классов, имплементирующих интерфейс `Swimmable`, должны уметь плавать»: вот и всё, что говорит нам интерфейс.

Как там конкретно будет плавать рыба, утка или лошадь — вопрос к классам `Fish`, `Duck` и `Horse`, а не к интерфейсу. Также как переключение канала — задача телевизора. Пульт просто предоставляет кнопку для этого.

В **Java 8** появилось интересное дополнение — методы по умолчанию (`default method`).

Например, в твоем интерфейсе есть 10 методов. 9 из них реализованы по-разному в разных классах, но один реализован одинаково у всех. Раньше, до выхода Java 8, методы внутри интерфейсов вообще не имели реализации: компилятор сразу выдавал ошибку. Теперь же можно сделать вот так:
```java
public interface Swimmable {

  /*public*/ default void swim() {
    System.out.println("Плыви!");
  }

  /*public*/ void eat();

  /*public*/ void run();
}
```

Используя ключевое слово `default`, мы создали в интерфейсе метод с реализацией по умолчанию.

Два других метода, `eat()` и `run()`, нам **необходимо** будет реализовать самим во всех классах, которые будут имплементировать `Swimmable`.

С методом `swim()` этого делать не нужно (но *можно*): по умолчанию реализация будет во всех классах одинаковой.
