import java.util.Arrays;

public class Task1BubbleSort {

  // Сортировка объектов
  // Для простоты - чисел по возрастанию.
  // Если мы сортируем объекты, то придётся пользоваться obj.compareTo() или comparator.compare().
  // Существует много алгоритмов сортировки. Они отличаются:
  // - скоростью (сложностью по времени),
  // - использованием дополнительной памяти (сложностью по памяти),
  // - стабильностью (сохранением порядка равных элементов),
  // - широтой применения (некоторые алгоритмы подходят только для ограниченного спектра объектов,
  //   например, чисел одинаковой длины).
  public static void main(String[] args) {
    int[] numbers = {4, 2, 5, 7, 3};
    bubbleSort(numbers, /*recursive=*/true);
    System.out.println(Arrays.toString(numbers)); // array.toString() - [I@2a84aee7
  }

  public static void bubbleSort(int[] array, boolean recursive) {
    if (recursive) {
      bubbleSortRecursive(array);
    } else {
      bubbleSortIterative(array);
    }
  }

  private static void bubbleSortIterative(int[] array) {
    // Отсортируем массив in-place - прямо на месте, не копируя.
    // Сортировки могут менять существующую коллекцию или возвращать новую, отсортированную,
    // не трогая старую.
    // Алгоритм сортировки: сортировка пузырьком (bubble sort).
    // За один проход в массиве на самое высокое (последнее) место должен подняться самый большой
    // "пузырёк" (элемент).
    // После этого проходим ещё раз, и из оставшихся самый большой (второй по величине) поднимается
    // на предпоследнее место.
    // Повторяем до тех пор, пока не закончатся элементы
    //             right
    // 4, 2, 5, 7, 3
    // 2, 4, 5, 7, 3
    // 2, 4, 5, 3, 7
    //          right
    // 2, 4, 5, 3 | 7
    // 2, 4, 3, 5
    //       right
    // 2, 4, 3 | 5, 7
    // 2, 3, 4
    //    right
    // 2, 3 | 4, 5, 7
    // right = 1..(n-1) - (n - 1) раз
    // (n-1) раз - ((n-1) * (n / 2)) операций = (n^2 / 2 - n/2) = (0.5 * n^2 - 0.5 * n) = O(n^2)
    for (int right = array.length - 1; right >= 1; --right) { // n раз по O(n) = O(n^2)
      // right - индекс последнего числа - места, куда поднимается самое большое
      // i < right, тогда (i + 1) <= right
      for (int i = 0; i < right; ++i) { // right = 1..(n-1) раз, в среднем (n / 2) раз = O(n)
        // если текущий элемент больше следующего - пузырьки стоят неправильно, надо поменять
        if (array[i] > array[i + 1]) { // сортировка стабильна - равные элементы не меняются местами
          int temp = array[i];
          array[i] = array[i + 1];
          array[i + 1] = temp;
        }
        // иначе всё и так хорошо, можно идти дальше
      }
    }
  }

  // запуск рекурсивной сортировки
  // лучше написать bubbleSort(int[] array), но такая сигнатура уже занята
  private static void bubbleSortRecursive(int[] array) {
    // выход из рекурсии
    // - массив не нужно сортировать - в нём меньше двух элементов
    // шаг рекурсии:
    // - нужно отсортировать массив из n элементов
    // - подняли наверх самый большой пузырёк
    // - остался неотсортированным массив из (n - 1) элементов - все, кроме последнего
    // - нужно отсортировать массив из (n - 1) элементов - рекурсия (с уменьшением размера)
    // создавать новый массив другого размера невыгодно ни по времени, ни по памяти
    // проще передавать в метод границу - размер неотсортированной части (right из метода выше)
    bubbleSortRecursive(array, array.length - 1); // запуск рекурсии с начальным значением last
  }

  // настоящий рекурсивный метод - для шага рекурсии нужно передавать размер неотсортированной части
  // перегрузка метода - название то же, аргументы другие (и этот метод приватный)
  private static void bubbleSortRecursive(int[] array, int last) {
//    System.out.println("bubbleSort(array=" + Arrays.toString(array) + ", last=" + last + ")");
    // выход из рекурсии
    // - массив не нужно сортировать - в нём меньше двух элементов
    if (last < 1) { // last = 0, остался единственный элемент с индексом 0 (или ничего не осталось)
      return; // выход из рекурсии
    }
    // шаг рекурсии - поднимаем наверх (в last) самый большой пузырёк
    for (int i = 0; i < last; ++i) {
      if (array[i] > array[i + 1]) {
        int temp = array[i];
        array[i] = array[i + 1];
        array[i + 1] = temp;
//        System.out.println(Arrays.toString(array));
      }
    }
    bubbleSortRecursive(array, last - 1); // шаг рекурсии - переход к массиву меньшего размера
  }
}
