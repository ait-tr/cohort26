# Наследование

Давайте поглубже разберем ещё один принцип ООП — **наследование**. Это очень интересная тема, которой вы будете пользоваться часто. Программирование, для несведущих, неотличимо от магии. Поэтому начнем с такой интересной аналогии.

## Расширение функционала

Предположим, что вы – волшебник и хотите создать летающую лошадь. С одной стороны, вы бы могли попробовать наколдовать пегаса. Но т.к. пегасов в природе не существует, это будет очень непросто. Придется очень многое делать самому. Куда проще взять лошадь и приколдовать ей крылья.

В программировании такой процесс называется «наследование». Предположим, вам нужно написать очень сложный класс. Писать с нуля долго, потом еще долго все тестировать и искать ошибки. Зачем идти самым сложным путем? Лучше поискать, а нет ли уже такого класса?

Предположим, вы нашли класс, который своими методами реализует 80% нужной вам функциональности. Что делать с ним дальше? Вы можете просто скопировать его код в свой класс. Но у такого решения есть несколько минусов:
- Найденный класс уже может быть скомпилирован в байт-код, а доступа к его исходному коду у вас нет.
- Исходный код класса есть, но вы работаете в компании, которую могут засудить на пару миллиардов за использование даже 6 строчек чужого кода. А потом она засудит вас.
- Ненужное дублирование большого объема кода. Кроме того, если автор чужого класса найдет в нем ошибку и исправит ее, у вас эта ошибка останется.

Есть решение потоньше, и без необходимости получать легальный доступ к коду оригинального класса. В Java вы можете просто объявить тот класс родителем вашего класса. Это будет эквивалентно тому, что вы добавили код того класса в код своего. В вашем классе появятся все данные и все методы класса-родителя. Например, можно делать так: наследуемся от «лошади», добавляем «крылья» – получаем «пегаса».

## Общий базовый класс

Наследование можно использовать и для других целей. Допустим, у вас есть десять классов, которые очень похожи, имеют совпадающие данные и методы. Вы можете создать специальный базовый класс, вынести эти данные (и работающие с ними методы) в этот базовый класс и объявить те десять классов его наследниками. Т.е. указать в каждом классе, что у него есть класс-родитель — данный базовый класс.

# Наследование в Java

## Схемы наследования

При проектировании возможна разная иерархия базовых классов (или суперклассов) и классов-наследников.

Три типа можно реализовать в Java:
![Single, Multilevel, Hierarchical](https://github.com/ait-tr/cohort26/raw/main/basic_programming/lesson_35/img/inheritance_1.png)

Ещё два типа иерархии предполагают множественное наследование, и в Java такое запрещено:
![Multiple, Hybrid](https://github.com/ait-tr/cohort26/raw/main/basic_programming/lesson_35/img/inheritance_2.png)

## Наследование в коде

Так что же нужно, чтобы унаследовать какой-то класс? Чтобы унаследовать один класс от другого, нужно после объявления нашего класса указать ключевое слово extends и написать имя родительского класса. Выглядит это обычно примерно так:

```java
class Потомок extends Родитель
```
Именно такую конструкцию нужно написать при объявлении класса Потомок. Наследоваться, кстати, можно **только от одного класса**.

# Проверка принадлежности

Иногда вы перебираете элементы списка объектов базового класса, и хотите узнать, не является ли конкретный элемент случайно конкретным потомком.

Это можно сделать при помощи специального служебного слова `instanceof`:
```java
for (Pet pet : pets) {
  pet.makeSomeNoise();
  if (pet instanceof Dog) { // если pet - разновидность класса Dog (Dog или его потомок)
    System.out.println(pet.getName() + " - собака!");
    Dog tempDog = (Dog) pet;
    tempDog.bringShoes(); // только с переменной класса Dog, а у нас List<Pet>
  }
}
```

Если при проверке переменную сразу нужно "привести" к типу-потомку (`Cat tempCat = (Cat) pet;`), то это можно сделать следующим, более коротким образом:
```java
for (Pet pet : pets) {
  pet.makeSomeNoise();
  if (pet instanceof Dog tempDog) {
    System.out.println(pet.getName() + " - собака!");
    tempDog.bringShoes(); // только с переменной класса Dog, а у нас List<Pet>
  }
}
```
