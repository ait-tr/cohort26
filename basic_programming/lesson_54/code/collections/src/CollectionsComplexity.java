public class CollectionsComplexity {

  // оценка сложности операций:
  // - обращение по индексу
  // - поиск
  // - вставка (в начало / в середину / в конец)
  // - удаление (из начала / из середины / с конца)
  // String (почти частный случай массива)
  // - обращение по индексу - O(1)
  // - поиск элемента - линейный поиск - O(n)
  // - вставка / удаление - не применимо (n/a - not applicable)
  // array (int[], Object[])
  // - обращение по индексу - O(1)
  // - поиск элемента - линейный поиск - O(n)
  // - вставка / удаление - не применимо (n/a - not applicable)
  // ArrayList (список на основе массива)
  // - обращение по индексу - O(1)
  // - поиск элемента - линейный поиск - O(n)
  // - вставка: в начало - O(n), в середину - O(n), в конец `.add()` - O(1) (и иногда O(n))
  // - удаление: из начала - O(n), из середины - O(n), с конца - O(1)
  // LinkedList (связный список) - состоит из узлов (Node), каждый из которых хранит ссылки соседей
  // - обращение по индексу - O(n)
  // - поиск элемента - линейный поиск - O(n)
  // - вставка: куда угодно, если мы уже там - O(1)
  // - удаление: откуда угодно, если мы уже там - O(1)
  // HashSet - хранение происходит по хэшу, а уже внутри по каждому хэшу - список
  //   при добавлении или поиске элемента вычисляем хэш, дальше линейный поиск среди элементов с
  //   таким же хэшем `Object.hashCode()`
  // - обращение по индексу - n/a
  // - поиск элемента - O(1), но вычисление хэша может быть долгим
  // - вставка: O(1) (и иногда O(n))
  // - удаление: O(1)
  // TreeSet - хранение происходит в упорядоченном дереве (слева меньше, справа больше)
  //   объекты должны быть Comparable или при создании надо передать Comparator
  //           корень
  //         /        \
  //     узел          узел
  //    /   \         /    \
  // лист   лист   лист    лист
  //   Пример:
  //       5
  //     /  \
  //    4    7
  //        /
  //       6
  // - обращение по индексу - n/a
  // - поиск элемента - бинарный - каждый переход вниз уменьшает дерево поиска в 2 раза - O(log n)
  // - вставка - поиск места O(log n) и вставка O(1) - O(log n)
  // - удаление - поиск O(log n) и удаление O(1) - O(log n)
  //   TreeSet ВСЕГДА упорядочена, вставка и удаление ничего не ломают
}
