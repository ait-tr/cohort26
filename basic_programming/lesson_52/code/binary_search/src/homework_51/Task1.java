package homework_51;

import java.util.Scanner;

public class Task1 {

  // Найти минимальное чётное число в последовательности положительных чисел
  // или вывести -1, если такого числа не существует.
  //
  // Оценить временную и пространственную сложность алгоритма.
  public static void main(String[] args) {
    // можно читать последовательность в список или массив
    // минус: сложность по памяти O(n)
    // можно читать и тут же забывать - сложность по памяти O(1)
    Scanner scanner = new Scanner(System.in);
    int n = scanner.nextInt();
    int m = minEven(scanner, n);
    System.out.println("Минимальное чётное: " + m);
  }

  public static int max(Scanner scanner, int n) {
    // n чисел
    // читаем первое заранее:
    int x = scanner.nextInt();
    int m = x; // "рамочка" по первому элементу
    for (int i = 0; i < n - 1; ++i) { // (n - 1) раз (кроме первого) сложность по времени O(n)
      x = scanner.nextInt(); // чтение следующего (нового) элемента
      if (x > m) { // если новый элемент больше,
        m = x; // то меняем (увеличиваем) "рамочку"
      }
    }
    // "рамочка" увеличилась до размера самого большого элемента
    return m; // вернули максимум ("рамочку") как результат работы метода
  }

  public static int min(Scanner scanner, int n) {
    // n чисел
    // читаем первое заранее:
    int x = scanner.nextInt();
    int m = x; // "рамочка" по первому элементу
    for (int i = 0; i < n - 1; ++i) { // (n - 1) раз (кроме первого) сложность по времени O(n)
      x = scanner.nextInt(); // чтение следующего (нового) элемента
      if (x < m) { // если новый элемент меньше,
        m = x; // то меняем (уменьшаем) "рамочку"
      }
    }
    // "рамочка" уменьшилась до размера самого маленького элемента
    return m; // вернули минимум ("рамочку") как результат работы метода
  }

  public static int minEven(Scanner scanner, int n) {
    int m = -1; // ставим "неправильно", чтобы понять, менялась ли рамочка
    for (int i = 0; i < n; ++i) { // n раз, сложность по времени O(n)
      int x = scanner.nextInt(); // чтение следующего (нового) элемента
      // если новый элемент чётный и (рамочка "неправильная" (не менялась) или элемент меньше)
      if (x % 2 == 0 && (m == -1 || x < m)) {
        m = x; // то меняем (уменьшаем) "рамочку"
      }
    }
    // "рамочка" уменьшилась до размера самого маленького чётного элемента или осталась -1
    return m; // вернули минимум ("рамочку") как результат работы метода
  }

  public static int minEvenFlag(Scanner scanner, int n) {
    boolean foundEven = false; // нашли ли чётный
    int m = -1;
    for (int i = 0; i < n; ++i) { // n раз, сложность по времени O(n)
      int x = scanner.nextInt(); // чтение следующего (нового) элемента
      // если новый элемент чётный и (не нашли чётный или элемент меньше)
      if (x % 2 == 0 && (!foundEven || x < m)) {
        m = x; // то меняем (уменьшаем) "рамочку"
        foundEven = true; // теперь нашли чётный
      }
    }
//    if (!foundEven) {
//      return -1;
//    } // после return не нужен else
//    return m;
    // или:
//    return foundEven ? m : -1;
    // или:
//    if (!foundEven) { // если ответ не нашли
//      m = -1; // то изменить ответ на "не найдено"
//    }
    // или:
    // "рамочка" уменьшилась до размера самого маленького чётного элемента или осталась -1
    return m; // вернули минимум ("рамочку") как результат работы метода
  }
}
