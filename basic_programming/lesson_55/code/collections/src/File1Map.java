public class File1Map {

  // - как работает бинарный поиск в дереве
  //   Пример:
  //       5
  //     /  \
  //    4    7
  //  /     / \
  // 2     6   8
  //  \
  //   3
  // LinkedHashSet* / LinkedHashMap* - сложность как у HashSet / HashMap, но дольше
  //   сохраняют порядок добавления
  // Map:
  // HashMap - как HashSet, но для ключей - использует hashCode() и equals()
  //  HashSet:
  //   {"мама", "мыла", "раму"}
  //   "мама" -> 33358312 -> shift (сдвиг = индекс в массиве) 0;
  //   "мыла" -> 33384228 -> shift 1;
  //   "раму" -> 33477495 -> shift 2;
  //  Поиск:
  //   "папа" -> 33447778 -> например, shift 1 -> там нет (там только "мыла") -> в множестве нет
  // - обращение по индексу - n/a
  // - поиск ключа - O(1), но вычисление хэша может быть долгим
  // - поиск значения - O(n) - перебор всех значений
  // - вставка: O(1) (и иногда O(n))
  // - удаление: O(1)
  // С точки зрения теории, `HashMap` - это `HashSet`, но со значениями
  // C точки зрения Java, `HashSet` - это `HashMap`, но без значений (только ключи)
  //
  // TreeMap - как TreeSet, но для ключей - использует compareTo() или comparator.compare()
  // - обращение по индексу - n/a
  // - поиск ключа - бинарный - каждый переход вниз уменьшает дерево поиска в 2 раза - O(log n)
  // - поиск значения - линейный - O(n)
  // - вставка - O(log n)
  // - удаление - O(log n)
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}
