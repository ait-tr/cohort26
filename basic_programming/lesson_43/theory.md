# Интерфейс `Comparable<?>`

Реализованный в `Comparable` метод сравнения называют «natural ordering» — естественной сортировкой. Это потому, что в методе `compareTo()` описывается наиболее распространенный способ сравнения, который будет использоваться для объектов этого класса в твоей программе.

Natural Ordering уже присутствует в Java. Например, Java знает, что строки чаще всего сортируют по алфавиту, а числа — по возрастанию их значения. Поэтому если вызвать на списке чисел или строк метод `sort()`, так они и будут отсортированы.

Если в нашей программе машины в большинстве случаев будут сравниваться и сортироваться по году выпуска, значит, стоит определить для них натуральную сортировку с помощью интерфейса `Comparable<Car>` и метода `compareTo()` (см. теоретичесий материал предыдущего урока).

Но что, если нам этого недостаточно?

Давайте представим, что наша программа не так проста.

В большинстве случаев натуральная сортировка машин (мы установили ее по году выпуска) нас устраивает.

Но иногда среди наших клиентов попадаются любители быстрой езды. Если мы готовим для них каталог автомобилей на выбор, их нужно упорядочить по максимальной скорости.

# Интерфейс `Comparator<?>`

К примеру, такая сортировка нам нужна в 15% случаев. Этого явно недостаточно, чтобы установить **натуральную сортировку** для `Car` по скорости вместо года выпуска.

Но и игнорировать 15% клиентов мы не можем. Что же нам делать?

Здесь нам приходит на помощь другой интерфейс — [`Comparator`](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Comparator.html). Так же, как и `Comparable`, он типизированный.

А в чем же разница?

`Comparable` делает наши объекты «сравнимыми» и создает для них наиболее естественный порядок сортировки, который будет использоваться в большинстве случаев.

`Comparator` — это отдельный класс-«сравниватель» (перевод немного корявый, но зато понятный).

Если нам нужно реализовать какую-то специфическую сортировку, нам необязательно лезть в класс `Car` и менять логику `compareTo()`.

Вместо этого мы можем создать **отдельный** класс-comparator в нашей программе и научить его делать нужную нам сортировку!

```java
import java.util.Comparator;

public class MaxSpeedCarComparator implements Comparator<Car> {

  @Override
  public int compare(Car o1, Car o2) {
    return o1.getMaxSpeed() - o2.getMaxSpeed();
  }
}
```

Как видите, наш `Comparator` довольно прост.

Всего один метод `compare()` — это метод интерфейса `Comparator`, который обязательно нужно реализовать. Он принимает на вход два объекта `Car` и привычным нам образом (вычитанием) сравнивает их максимальную скорость. Как и `compareTo()`, он возвращает число `int`, принцип сравнения тот же.

Как же нам пользоваться этим?

Очень просто:
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {

  public static void main(String[] args) {

    List<Car> cars = new ArrayList<>();
    cars.add(new Car(1990, "Ferrari 360 Spider", 310));
    cars.add(new Car(2010, "Bugatti Veyron", 350));
    cars.add(new Car(2012, "Lamborghini Gallardo", 290));

    Comparator speedComparator = new MaxSpeedCarComparator();
    Collections.sort(cars, speedComparator);

    System.out.println(cars);
  }
}
```
Вывод в консоль:
```
[Car{manufactureYear=2012, model='Lamborghini Gallardo', maxSpeed=290},
Car{manufactureYear=1990, model='Ferrari 360 Spider', maxSpeed=310}, 
Car{manufactureYear=2010, model='Bugatti Veyron', maxSpeed=350}]
```

Мы просто создаем объект-компаратор и передаем его в метод `Collections.sort()` вместе со списком, который надо отсортировать.

Получив на вход компаратор, метод `sort()` не будет использовать естественную сортировку, определенную в методе `compareTo()` класса `Car`. Вместо этого он применит алгоритм сортировки из переданного ему компаратора.

Какие плюсы нам это дает?

Во-первых, совместимость с написанным кодом. Мы создали новый, специфический метод сортировки, и при этом сохранили действующий, который будет использоваться в большинстве случаев.

Мы вообще не трогали класс `Car`.
Он как был `Comparable`, так и остался.

Во-вторых, гибкость. Мы можем добавлять сколько угодно сортировок.

Скажем, отсортировать машины по цвету, скорости, весу, или по тому, сколько раз эта машина использовалась в фильмах про Бэтмена. Достаточно только создать дополнительный `Comparator`.
