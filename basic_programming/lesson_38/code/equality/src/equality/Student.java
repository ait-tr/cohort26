package equality;

public class Student {

  private String name;
  private int age;

  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return "Студент по имени " + name + " (возраст: " + age + ")";
  }

  @Override
  public boolean equals(Object obj) {
    // метод equals переопределяет сравнение объектов
    // должен возвращать true, когда объекты равны
    // первое условие -- "ускорение" работы -- нам даже не надо сравнивать содержимое,
    // если ссылки ведут на один и тот же объект
    if (this == obj) { // this -- это ссылка на текущий объект
      return true; // сравниваем объект сам с собой
    }
    if (!(obj instanceof Student objStudent)) { // является экземпляром класса Student
      // instance - пример, экземпляр, образец
      return false; // если объект в скобочках - не студент (не класс Student или его наследник)
    }
    // выше произошло:
    // Student objStudent = (Student) obj;
    // чтобы получить доступ к методам класса

    // здесь определение того, что мы считаем совпадающими (или одинаковыми) объектами
    // это один и тот же студент, если совпадают имя и возраст
    return name.equals(objStudent.getName()) && age == objStudent.getAge();

    // В методе `equals` для класса чаще всего в конце просто вызываются методы
    // `equals` для атрибутов этого класса и их результат объединяется через && (логическое И)
  }

  // метод hashCode() определяет хэш-код объекта - целое число, используемое Java для
  // ускорения сравнения.
  // Каждый раз, когда вы кладёте объект в HashSet или как ключ в HashMap,
  // чтобы понять, есть ли такой объект, сначала вычисляется хэш, и сравниваются через
  // equals только объекты с одинаковым хэшем.

  // Что это значит:
  // - по умолчанию у разных объектов разный хэш (его генерирует Java).
  //   Это значит, что разные объекты будут считаться "не совпадающими" в HashSet, даже если
  //   equals показывает, что они совпадают.
  // - если вы переопределили equals(), то для "теперь одинаковых" объектов должен совпадать хэш,
  //   и надо переопределить hashCode().
  // - если hashCode() для всех объектов возвращает одно и то же, то HashMap и HashSet будут ОЧЕНЬ
  //   медленно работать. Значит, надо постараться сделать так, чтобы для разных (с точки зрения
  //   equals() объектов хэш-код тоже был разным).
  @Override
  public int hashCode() {
//    return 0; // так будет очень медленно, но будет работать
    return name.hashCode() + age; // сложили int и int
    // смысл:
    // - если числа разные, значит, объекты ТОЧНО разные
    // - если числа одинаковые, значит, объекты надо сравнить через equals()
  }

  // Итог: если мы переопределили equals() и сказали, что разные (в памяти) объекты должны считаться
  // одинаковыми (равными), то мы обязаны переопределить hashCode(), чтобы для этих "одинаковых"
  // объектов метод hashCode() возвращал ОДИНАКОВОЕ число.
  // Если не переопределить hashCode(), то возвращаемое число останется разным, и HashSet / HashMap
  // не сможет проверять уникальность наших объектов.
}
